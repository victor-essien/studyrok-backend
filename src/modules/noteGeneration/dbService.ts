

import { prisma } from "@/lib/prisma";

type CreateSection = {
  topicId: string;
  title: string;
  description?: string;
  orderIndex: number;
  depthLevel: 'FOUNDATIONAL' | 'INTERMEDIATE' | 'ADVANCED';
  status?: 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED';
}


//  NOTE: Topic here means note generated by a topic inputed
export class DatabaseService {
  async createTopic(data: {
    userId?: string;
    title: string;
    difficulty: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';
    description?: string;
    status?: 'GENERATING' | 'COMPLETED' | 'FAILED';
  }) {
    // cast prisma to any to avoid missing generated model typings in this environment
    return await prisma.topic.create({
      data: {
        userId: data.userId ?? null,
        title: data.title,
        description: data.description ?? null,
        difficulty: data.difficulty,
        status: data.status || 'GENERATING',
      },
    });
  }
async updateTopic(topicId: string, data: any
//   {
//     title?: string;
//     difficulty?: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';
//     description?: string;
//     status?: 'GENERATING' | 'COMPLETED' | 'FAILED';
// }
) {
    return await prisma.topic.update({
      where: { id: topicId },
      data,
    });
  }


  async getTopic(topicId: string) {
     return await prisma.topic.findUnique({
      where: {id: topicId}
     })
  }

  async getTopicStatus(topicId: string) {
    const topic = await prisma.topic.findUnique({
      where: {id: topicId}, 
      include: {
        sections: {
          select: {
            id: true,
            status: true,
          },
        },
        notes: {
          select: {
            id: true,
            status: true
          }
        }
      }
    })

    if (!topic) return null;

    const sectionsCompleted = topic.sections.filter(s => s.status === 'COMPLETED').length;
    const notesCompleted = topic.notes.filter(n => n.status === 'COMPLETED');

    return {
      ...topic,
      sectionCount: topic.sections.length,
      notesCount: topic.notes.length,
      sectionsCompleted,
      notesCompleted
    }
  }

  async getTopicWithContent(topicId: string) {
    return await prisma.topic.findUnique({
      where: {id: topicId},
      include: {
        sections: {
          orderBy: {orderIndex: 'asc'},
          include: {
            notes: {
              orderBy: {orderIndex: 'asc'}
            }
          }
        }
      }
    })
  }

  async listTopics(userId?: string, limit: number = 50, offset: number = 0) {
    
    const where = userId ? {userId} : {};

    return await prisma.topic.findMany({
      where,
      take: limit,
      skip: offset,
      orderBy: {createdAt: 'desc'}
    })
  }


  async createSection(data: CreateSection) {
    return await prisma.section.create({
      data: {
        topicId: data.topicId,
        title: data.title,
        description: data.description ?? null,
        orderIndex: data.orderIndex,
        depthLevel: data.depthLevel,
        status: data.status || 'PENDING'
      }
    })
  }

 async updateSection(sectionId: string, data: any
//   {
//    title?: string;
//     description?: string;
//     status?: 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED'
//  }
) {
  return await prisma.section.update({
    where: {id: sectionId},
    data
  })
 }


 async getSection(sectionId: string) {
  return await prisma.section.findUnique({
    where: {id: sectionId},
    include: {
      notes: {
        orderBy: {orderIndex: 'asc'}
      }
    }
  })
 }

 async createNote(data: {
  topicId: string;
  sectionId: string;
  title: string;
  content: string;
  summary?: string;
  orderIndex: number;
  depthLevel: 'FOUNDATIONAL' | 'INTERMEDIATE' | 'ADVANCED';
  wordCount: number;
  estimatedReadTime: number;
  includesExamples: boolean;
  includesCode: boolean;
  includesDiagrams: boolean;
  tags?: string[];
  status?: 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED';
 }) {
  return await prisma.note.create({ 
    data: {
      topicId: data.topicId,
      sectionId: data.sectionId,
      title: data.title,
      content: data.content,
      summary: data.summary ?? null,
      orderIndex: data.orderIndex,
      depthLevel: data.depthLevel,
      wordCount: data.wordCount,
      estimatedReadTime: data.estimatedReadTime,
      includesExamples: data.includesExamples,
      includesCode: data.includesCode,
      includesDiagrams: data.includesDiagrams,
      tags: data.tags || [] ,
      status: data.status || 'PENDING'
    }
  })
}

async getNote(noteId: string) {
  return await prisma.note.findUnique({
    where: {id: noteId},
    include: {
      section: {
        select: {
          title: true
        },
      },
      concepts: true
    }
  })
 }

 async updateNote(noteId: string, data: {
  title?: string;
  content?: string;
  summary?: string;
  status?: 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED';
 }) {
  return await prisma.note.update({
    where: {id: noteId},
    data

 })
}


// ===================== CONCEPTS =====================


async createConcept(data: {
  noteId: string;
  topicId: string;
  term: string;
  definition: string;
  importance: 'CRITICAL' | 'IMPORTANT' | 'SUPPLEMENTARY';
}) {
  return await prisma.concept.create({
    data,
  });
}

async getConceptsByNote(noteId: string) {
  return await prisma.concept.findMany({
    where: {noteId}, 
    orderBy: {importance: 'asc'},
  })
}

async getConceptsByTopic(topicId: string) {
  return await prisma.concept.findMany({
    where: {topicId},
    orderBy: {term: 'asc'},
  })
}

// ============== NOTE RELATIONSHIPS ==============

async createNoteRelationship(data: {
  sourceNoteId: string;
  targetNoteId: string;
  relationshipType: 'PREREQUISITE' | 'RELATED' | 'ADVANCED_TOPIC' | 'SEE_ALSO' ;
}) {
    return await prisma.noteRelationship.create({
      data
    })
}

async getNoteRelationships(noteId: string) {
    return await prisma.noteRelationship.findMany({
      where: {
        OR: [
          { sourceNoteId: noteId },
          { targetNoteId: noteId },
        ],
      },
      include: {
        sourceNote: {
          select: {
            id: true,
            title: true,
          },
        },
        targetNote: {
          select: {
            id: true,
            title: true,
          },
        },
      },
    });
  }

  // ================================ USER PROGRESS ================================

  async trackProgress(data: {
    userId: string;
    noteId: string;
    topicId: string;
    status: 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED' | 'REVIEWED';
    progressPercentage: number;
    timeSpent: number
  }) {
    return await prisma.userProgress.upsert({
      where: {
        userId_noteId: {
          userId: data.userId,
          noteId: data.noteId,
        },
      },
      update: {
        status: data.status,
        progressPercentage: data.progressPercentage,
        timeSpent: {
          increment: data.timeSpent || 0,
        },
        lastAccessed: new Date(),
        completedAt: data.status === 'COMPLETED' ? new Date() : null,
      },
      create: {
         userId: data.userId,
        noteId: data.noteId,
        status: data.status,
        progressPercentage: data.progressPercentage || 0,
        timeSpent: data.timeSpent || 0,
        lastAccessed: new Date(),
        completedAt: data.status === 'COMPLETED' ? new Date() : null,
      },
    
    })
  }

  async getUserProgress(userId: string, topicId: string) {
    const topic = await prisma.topic.findUnique({
      where: { id: topicId },
      select: {
        title: true,
        totalNotes: true,
      },
    });

    if (!topic) return null;

    const progress = await prisma.userProgress.findMany({
      where: {
        userId,
        note: {
          topicId,
        },
        status: {
          in: ['COMPLETED', 'REVIEWED'],
        },
      },
    });

    const totalTimeSpent = progress.reduce((sum, p) => sum + p.timeSpent, 0);

    return {
      topicTitle: topic.title,
      totalNotes: topic.totalNotes,
      completedNotes: progress.length,
      completionPercentage: topic.totalNotes > 0 
        ? Math.round((progress.length / topic.totalNotes) * 100)
        : 0,
      totalTimeSpent,
    };
  }

  // ============== GENERATION HISTORY ==============

  async logGeneration(data: {
    topicId: string;
    userId?: string;
    generationType: 'FULL_TOPIC' | 'SECTION' | 'NOTE' | 'REGENERATION';
    aiModel: string;
    tokensUsed?: number;
    generationTime: number;
    success: boolean;
    errorMessage?: string;
  }) {
    return await prisma.generationHistory.create({
      data: {
        topicId: data.topicId,
        userId: data.userId ?? null,
        generationType: data.generationType,
        aiModel: data.aiModel,
        tokensUsed: data.tokensUsed ?? null,
        generationTime: data.generationTime,
        success: data.success,
        errorMessage: data.errorMessage ?? null,
      },
    });
  }

  async getGenerationHistory(topicId: string) {
    return await prisma.generationHistory.findMany({
      where: { topicId },
      orderBy: { createdAt: 'desc' },
    });
  }

 

  // ==================== UTILITY METHODS ====================

  async getTopicStatistics(topicId: string) {
    const stats = await prisma.topic.findUnique({
      where: { id: topicId },
      include: {
        _count: {
          select: {
            sections: true,
            notes: true,
            concepts: true,
          },
        },
        sections: {
          select: {
            estimatedReadTime: true,
          },
        },
      },
    });

    if (!stats) return null;

    const totalReadTime = stats.sections.reduce(
      (sum, section) => sum + (section.estimatedReadTime || 0),
      0
    );

    return {
      totalSections: stats._count.sections,
      totalNotes: stats._count.notes,
      totalConcepts: stats._count.concepts,
      estimatedReadTime: totalReadTime,
    };
  }

 async searchNotes(query: string, topicId?: string) {
  return prisma.note.findMany({
    where: {
      OR: [
        { title: { contains: query, mode: 'insensitive' } },
        { content: { contains: query, mode: 'insensitive' } },
        { summary: { contains: query, mode: 'insensitive' } },
      ] ,
      ...(topicId ? { topicId } : {}),
    },
    take: 20,
    include: {
      section: { select: { title: true } },
      topic: { select: { title: true } },
    },
  });
}


  // ==================== CLEANUP ====================

  async deleteTopic(topicId: string) {
    // Prisma will cascade delete all related records
    return await prisma.topic.delete({
      where: { id: topicId },
    });
  }

 

}