

import { prisma } from "@/lib/prisma";
import logger from "@/utils/logger";
import Prisma from "@prisma/client";

//  NOTE: Topic here means note generated by a topic inputed
export class DatabaseService {
  async createTopic(data: {
    userId?: string;
    title: string;
    difficulty: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';
    description?: string;
    status?: 'GENERATING' | 'COMPLETED' | 'FAILED';
  }) {
    // cast prisma to any to avoid missing generated model typings in this environment
    return await prisma.topic.create({
      data: {

        title: data.title,
        difficulty: data.difficulty,
        status: data.status || 'GENERATING',
         ...(data.userId && { userId: data.userId }),
      ...(data.description && { description: data.description }),
      },
    });
  }
async updateTopic(topicId: string, data: {
    title?: string;
    difficulty?: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';
    description?: string;
    status?: 'GENERATING' | 'COMPLETED' | 'FAILED';
}) {
    return await prisma.topic.update({
      where: { id: topicId },
      data,
    });
  }


  async getTopic(topicId: string) {
     return await prisma.topic.findUnique({
      where: {id: topicId}
     })
  }

  async getTopicStatus(topicId: string) {
    const topic = await prisma.topic.findUnique({
      where: {id: topicId}, 
      include: {
        sections: {
          select: {
            id: true,
            status: true,
          },
        },
        notes: {
          select: {
            id: true,
            status: true
          }
        }
      }
    })

    if (!topic) return null;

    const sectionsCompleted = topic.sections.filter(s => s.status === 'COMPLETED').length;
    const notesCompleted = topic.notes.filter(n => n.status === 'COMPLETED');

    return {
      ...topic,
      sectionCount: topic.sections.length,
      notesCount: topic.notes.length,
      sectionsCompleted,
      notesCompleted
    }
  }

  async getTopicWithContent(topicId: string) {
    return await prisma.topic.findUnique({
      where: {id: topicId},
      include: {
        sections: {
          orderBy: {orderIndex: 'asc'},
          include: {
            notes: {
              orderBy: {orderIndex: 'asc'}
            }
          }
        }
      }
    })
  }

  async listTopics(userId?: string, limit: number = 50, offset: number = 0) {
    
    const where = userId ? {userId} : {};

    return await prisma.topic.findMany({
      where,
      take: limit,
      skip: offset,
      orderBy: {createdAt: 'desc'}
    })
  }
}
