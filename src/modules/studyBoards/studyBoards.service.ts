import { prisma } from '@/lib/prisma';
import {
  NotFoundError,
  ConflictError,
  AuthorizationError,
  ValidationError,
} from '@/utils/errors';
import logger from '@/utils/logger';
import {
  CreateStudyBoardBody,
  UpdateStudyBoardBody,
  StudyBoardFilters,
  GeneratedMaterial,
  UploadedFile,
} from '@/types/studyBoard.types';
import { paginate, buildPaginationMeta } from '@/utils/helpers';
// TODO: Implement study board views
class StudyBoardService {
  async createStudyBoard(userId: string, data: CreateStudyBoardBody) {
    const { title, description, colorTheme, emoji, tags, isPublic } = data;

    const studyBoard = await prisma.studyBoard.create({
      data: {
        userId,
        title,
        description: description ?? null,
        sourceType: '',
        emoji: emoji ?? null,
        colorTheme: colorTheme || 'purple',
        tags: tags || [],
        isPublic: isPublic || false,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });
    logger.info(
      `Studyboar created with ID: ${studyBoard.id} by User: ${userId}`
    );
    return studyBoard;
  }

  async addTopicMaterial(userId: string, boardId: string, topic: string) {
    //    Check if board exists and user owns it
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!board) {
      throw new NotFoundError('Study board');
    }

    if (board.userId !== userId) {
      throw new AuthorizationError(
        'You do not have the permission to modify this study board'
      );
    }
    // Check if board already has material
    if (board.sourceType) {
      throw new ConflictError(
        'Study board already has material. Delete existing material first or create a new board.'
      );
    }

    // TODO: Call AI service to generate content from topic
    const generatedMaterial: GeneratedMaterial = {
      format: 'markdown',
      content: `# ${topic}\n\n## Introduction\n\nContent will be generated by AI...`,
      wordCount: 0,
      readTimeMinutes: 0,
      sections: ['Introduction'],
    };

    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        sourceType: 'topic',
        topic,
        generatedMaterial: generatedMaterial as any,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    logger.info(`Topic material added to board: ${boardId} by user: ${userId}`);
    return updatedBoard;
  }
  // Add uploaded material to study board
  async addUploadMaterial(
    userId: string,
    boardId: string,
    fileData: UploadedFile
  ) {
    //  Check if board exists and user owns it
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });
    if (!board) {
      throw new NotFoundError('Study board');
    }

    if (board.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to modify this study board'
      );
    }

    // Check if board already has material
    if (board.sourceType) {
      throw new ConflictError(
        'Study board already has material. Delete existing material first or create a new board.'
      );
    }

    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        sourceType: 'upload',
        uploadedFile: fileData as any,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    logger.info(
      `Upload material added to board: ${boardId} by user: ${userId}`
    );

    return updatedBoard;
  }

  // Remove materail from board
  async removeMaterial(userId: string, boardId: string) {
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!board) {
      throw new NotFoundError('Study board');
    }

    if (board.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to modify this study board'
      );
    }

    if (!board.sourceType) {
      throw new ValidationError('Study board has no material to remove');
    }

    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        sourceType: '',
        topic: null,
        // generatedMaterial: null,
        // uploadedFile: prisma.Json
      },
    });
    logger.info(`Material removed from board: ${boardId} by user: ${userId}`);

    return updatedBoard;
  }

  //  Get all boards

  async getAllBoards(userId: string, filters: any) {
    //Studyboardfilters
    const {
      subject,
      tags,
      isArchived,
      isFavorite,
      sourceType,
      search,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = filters;

    const page = parseInt(filters.page as any) || 1;
    const limit = parseInt(filters.limit as any) || 10;

    // Build where clause
    const where: any = {
      userId,
    };
    if (subject) where.subject = subject;
    if (isArchived !== undefined) where.isArchived = isArchived;
    if (isFavorite !== undefined) where.isFavorite = isFavorite;
    if (sourceType) where.sourceType = sourceType;

    if (tags && tags.length > 0) {
      where.tags = {
        hasSome: tags,
      };
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { topic: { contains: search, mode: 'insensitive' } },
      ];
    }

    // Get boards with pagination
    const [boards, total] = await Promise.all([
      prisma.studyBoard.findMany({
        where,
        ...paginate(page, limit),
        orderBy: { [sortBy]: sortOrder },
        include: {
          _count: {
            select: {
              flashcardSets: true,
              quizzes: true,
            },
          },
        },
      }),
      prisma.studyBoard.count({ where }),
    ]);

    return {
      data: boards,
      meta: buildPaginationMeta(total, page, limit),
    };
  }

  //  Get single studyboard

  async getBoardById(userId: string, boardId: string) {
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        flashcardSets: {
          select: {
            id: true,
            title: true,
            numberOfCards: true,
            difficulty: true,
            lastStudied: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
        },

        quizzes: {
          select: {
            id: true,
            title: true,
            numberOfQuestions: true,
            difficulty: true,
            isCompleted: true,
            score: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
        },
        studySession: {
          select: {
            id: true,
            sessionType: true,
            durationMinutes: true,
            accuracy: true,
            startedAt: true,
          },
          orderBy: { startedAt: 'desc' },
          take: 5,
        },
      },
    });

    if (!board) {
      throw new NotFoundError('Study board');
    }

    // Check if user owns the board or if it's public
    if (board.userId !== userId && !board.isPublic) {
      throw new AuthorizationError(
        'You do not have permission to access this study board'
      );
    }

    return board;
  }

  async updateBoard(
    userId: string,
    boardId: string,
    data: UpdateStudyBoardBody
  ) {
    // Check if board exists and user owns it
    const existingBoard = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!existingBoard) {
      throw new NotFoundError('Study board');
    }
    if (existingBoard.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to update this study board'
      );
    }
    // Update board
    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    logger.info(`Study board updated: ${boardId} by user: ${userId}`);

    return updatedBoard;
  }

  // Delete Study board

  async deleteBoard(userId: string, boardId: string) {
    // Check if board exists and user owns it
    const existingBoard = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!existingBoard) {
      throw new NotFoundError('Study board');
    }

    if (existingBoard.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to delete this study board'
      );
    }

    // TODO: If it has uploaded file, delete form R2 storage

    await prisma.studyBoard.delete({
      where: { id: boardId },
    });

    logger.info(`Study board deleted: ${boardId} by user: ${userId}`);
  }

  // Toggle Archive status
  async toggleArchive(userId: string, boardId: string) {
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!board) {
      throw new NotFoundError('Study board');
    }

    if (board.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to modify this study board'
      );
    }

    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        isArchived: !board.isArchived,
      },
    });

    logger.info(
      `Study board ${updatedBoard.isArchived ? 'archived' : 'unarchived'}: ${boardId}`
    );
    return updatedBoard;
  }

  //  Toggle favorite status
  async toggleFavorite(userId: string, boardId: string) {
    const board = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!board) {
      throw new NotFoundError('Study board');
    }

    if (board.userId !== userId) {
      throw new AuthorizationError(
        'You do not have permission to modify this study board'
      );
    }

    const updatedBoard = await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        isFavorite: !board.isFavorite,
      },
    });

    logger.info(`Study board favorite toggled: ${boardId}`);

    return updatedBoard;
  }

  async getBoardStats(userId: string) {
    const [
      totalBoards,
      archivedBoards,
      favoriteBoards,
      studyTimeData,
      flashcardsCount,
      quizzesCount,
      recentBoards,
    ] = await Promise.all([
      prisma.studyBoard.count({
        where: { userId, isArchived: false },
      }),
      prisma.studyBoard.count({
        where: { userId, isArchived: true },
      }),
      prisma.studyBoard.count({
        where: { userId, sourceType: '' },
      }),
      prisma.studyBoard.aggregate({
        where: { userId },
        _sum: {
          totalStudyTime: true,
        },
      }),
      prisma.flashcard.count({
        where: { userId },
      }),
      prisma.quiz.count({
        where: { userId },
      }),
      prisma.studyBoard.findMany({
        where: { userId, lastStudiedAt: { not: null } },
        select: {
          id: true,
          title: true,
          lastStudiedAt: true,
        },
        orderBy: { lastStudiedAt: 'desc' },
        take: 5,
      }),
    ]);

    return {
      totalBoards,
      archivedBoards,
      favoriteBoards,
      //   boardsWithMaterial,
      //   boardsWithoutMaterial,
      totalStudyTime: studyTimeData._sum.totalStudyTime || 0,
      totalFlashcards: flashcardsCount,
      totalQuizzes: quizzesCount,
      recentActivity: recentBoards.map((board) => ({
        boardId: board.id,
        boardTitle: board.title,
        lastStudied: board.lastStudiedAt!,
      })),
    };
  }

  //   Get recently accessed boards

  async getRecentBoards(userId: string, limit: number = 5) {
    const boards = await prisma.studyBoard.findMany({
      where: {
        userId,
        isArchived: false,
      },
      orderBy: [{ lastStudiedAt: 'desc' }, { updatedAt: 'desc' }],
      take: limit,
      select: {
        id: true,
        title: true,
        description: true,
        subject: true,
        sourceType: true,
        colorTheme: true,
        thumbnail: true,
        emoji: true,
        flashcardsCount: true,
        quizzesCount: true,
        lastStudiedAt: true,
        updatedAt: true,
      },
    });
    return boards;
  }

  //  Get favorite boards
  async getFavoriteBoards(userId: string) {
    const boards = await prisma.studyBoard.findMany({
      where: {
        userId,
        isFavorite: true,
        isArchived: false,
      },
      orderBy: { updatedAt: 'desc' },
      select: {
        id: true,
        title: true,
        description: true,
        subject: true,
        sourceType: true,
        colorTheme: true,
        thumbnail: true,
        emoji: true,
        flashcardsCount: true,
        quizzesCount: true,
        lastStudiedAt: true,
        createdAt: true,
      },
    });
  }

  // Duplicate board
  async duplicateBoard(userId: string, boardId: string) {
    const originalBoard = await prisma.studyBoard.findUnique({
      where: { id: boardId },
    });

    if (!originalBoard) {
      throw new NotFoundError('Study board');
    }

    // Check permissions
    if (originalBoard.userId !== userId && !originalBoard.isPublic) {
      throw new AuthorizationError(
        'You do not have permission to duplicate this study board'
      );
    }

    // Create duplicate
    const duplicatedBoard = await prisma.studyBoard.create({
      data: {
        userId, // Assign to current user
        title: `${originalBoard.title} (Copy)`,
        description: originalBoard.description,
        subject: originalBoard.subject,
        sourceType: originalBoard.sourceType,
        topic: originalBoard.topic,
        // generatedMaterial: originalBoard.generatedMaterial,
        // uploadedFile: originalBoard.uploadedFile,
        colorTheme: originalBoard.colorTheme,
        emoji: originalBoard.emoji,
        tags: originalBoard.tags,
        isPublic: false, // Duplicates are private by default
      },
    });

    logger.info(
      `Study board duplicated: ${boardId} -> ${duplicatedBoard.id} by user: ${userId}`
    );

    return duplicatedBoard;
  }

  // Update study time

  async updateStudyTime(boardId: string, minutes: number) {
    await prisma.studyBoard.update({
      where: { id: boardId },
      data: {
        totalStudyTime: {
          increment: minutes,
        },
        lastStudiedAt: new Date(),
      },
    });
    logger.info(
      `Study time updated for board: ${boardId} - ${minutes} minutes`
    );
  }
}

export default new StudyBoardService();
